import logging
import json
import pathlib
import sys

import click

from rich.logging import RichHandler
from rich.console import Console

from .help.log import JSONSequenceHandler
from .parse.document import Omnifest
from .transform import resolve
from .transform.context import Context


log = logging.getLogger(__name__)


@click.group()
@click.option(
    "-v",
    "--verbose",
    count=True,
    help="Sets verbosity. Can be passed multiple times to be more verbose.",
)
@click.option(
    "-j/",
    "--json/--no-json",
    default=False,
    help="Sets output format to JSONseq. Output on stderr will be JSONseq records with ASCII record separators.",
)
@click.option(
    "-i",
    "--identifier",
    help="An identifier to include in all log records generated by `otk -j`. Can only be used together with `-j`.",
)
@click.option(
    "-w",
    "--warn",
    type=click.Choice(["duplicate-definition"]),
    multiple=True,
    help="Enable warnings, can be passed multiple times.",
)
@click.pass_context
def root(
    ctx: click.Context, verbose: int, json: bool, identifier: str, warn: list[str]
) -> None:
    """`otk` is the omnifest toolkit. A program to work with omnifest inputs
    and translate them into the native formats for image build tooling."""

    ctx.ensure_object(dict)

    logging.basicConfig(
        level=logging.WARNING - (10 * verbose),
        handlers=[
            (
                JSONSequenceHandler(identifier, stream=sys.stderr)
                if json
                else RichHandler(
                    omit_repeated_times=False,
                    show_path=False,
                    console=Console(stderr=True),
                )
            )
        ],
    )

    # This context is passed along to all other subcommands.
    ctx.obj["context"] = {
        "duplicate_definitions_warning": "duplicate-definition" in warn,
    }

    # We do this check *after* setting up the handlers so the error is formatted
    if identifier and not json:
        log.error("cannot use `-i` without also using `-j`")
        sys.exit(1)


@root.command()
@click.argument("input", type=click.Path(exists=True))
@click.argument("output", type=click.Path(), required=False)
@click.pass_context
def compile(ctx: click.Context, input: str, output: str | None) -> None:
    """Compile a given omnifest into its targets."""

    log.info("Compiling the input file %r to %r", input, output)


@root.command()
@click.argument("input", type=click.Path(exists=True))
@click.argument("output", type=click.Path(), required=False)
@click.pass_context
def flatten(ctx: click.Context, input: str, output: str | None) -> None:
    """Flatten a given omnifest by performing all includes."""

    log.info("flattening %r to %r", input, output or "STDOUT")

    file = pathlib.Path(input)
    root = file.parent

    # TODO posixpath serializer for json output
    log.info("include root is %r", str(root))

    context = Context(root, **ctx.obj["context"])

    omni = Omnifest.from_yaml_path(file)
    tree = omni.to_tree()

    prev_tree = tree
    step_tree = 0

    while True:
        step_tree += 1

        log.debug("resolve cycle %r", step_tree)

        next_tree = resolve(context, prev_tree)
        if prev_tree == next_tree:
            break

        prev_tree = next_tree

    tree = next_tree

    log.debug("tree is stable")

    print(json.dumps(tree, indent=2))
